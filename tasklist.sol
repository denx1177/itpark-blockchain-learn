
/**
 * This file was generated by TONDev.
 * TONDev is a part of TON OS (see http://ton.dev).
 */
pragma ton-solidity >= 0.35.0;
pragma AbiHeader expire;

// This is class that describes you smart contract.
contract tasklist {
    // Contract can have an instance variables.
    // In this example instance variable `timestamp` is used to store the time of `constructor` or `touch`
    // function call
    uint32 public timestamp;
    struct task {
        string name;
        uint32 time;
        bool flag;
    }
    mapping (int8 => task) taskList;

    int8 public indexGlobal = 0;

    // Contract can have a `constructor` â€“ function that will be called when contract will be deployed to the blockchain.
    // In this example constructor adds current time to the instance variable.
    // All contracts need call tvm.accept(); for succeeded deploy
    constructor() public {
        // Check that contract's public key is set
        require(tvm.pubkey() != 0, 101);
        // Check that message has signature (msg.pubkey() is not zero) and
        // message is signed with the owner's private key
        require(msg.pubkey() == tvm.pubkey(), 102);
        // The current smart contract agrees to buy some gas to finish the
        // current transaction. This actions required to process external
        // messages, which bring no value (henceno gas) with themselves.
        tvm.accept();
        timestamp = now;
    }

      // Modifier that allows to accept some external messages
	modifier checkOwnerAndAccept {
		// Check that message was signed with contracts key.
		require(msg.pubkey() == tvm.pubkey(), 102);
		tvm.accept();
		_;
	}

    function taskAdd(string taskName) public checkOwnerAndAccept {
        bytes a = taskName;
		require(a.length > 0, 100, "incorrect taskName");
        indexGlobal ++;
        taskList[indexGlobal] = task(taskName, now, false);
	}

    function NumberofOpenTasks1() public checkOwnerAndAccept returns (int8 openTasks) {
        for (int8 index = 1; index <= indexGlobal; index++) {
            if (taskList.exists(index)){
                if (!taskList[index].flag) {
                    openTasks ++;
                }
            }
        }
	}

        function NumberOfOpenTasks2() public checkOwnerAndAccept returns (int8 openTasks) {
        for((int8 key, task value) : taskList){
                if (!taskList[key].flag) {
                    openTasks ++;
                }
        }
	}

    function printTasksInString() public checkOwnerAndAccept returns (string openTasks) {
        for (int8 index = 1; index <= indexGlobal; index++) {
            if (taskList.exists(index)){
                openTasks.append(taskList[index].name);
                openTasks.append("  ");
            }
        }
	}

    function printTasksArray() public checkOwnerAndAccept returns (task[] tasksOut) {
        for((int8 key, task value) : taskList){
            tasksOut.push(value);
        }
	}

    function taskPrintKey (int8 index) public checkOwnerAndAccept returns (task) {
        require(taskList.exists(index), 100, "incorrect index. task does not exist");
        return taskList[index];
	}

     function taskDone(int8 index) public checkOwnerAndAccept {
        require(taskList.exists(index), 100, "incorrect index. task does not exist");
        taskList[index].flag = true;
	}

    function deleteTask(int8 index) public checkOwnerAndAccept {
    require(taskList.exists(index), 100, "incorrect index. task does not exist");
    delete taskList[index];
}

}
